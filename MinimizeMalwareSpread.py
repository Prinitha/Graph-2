'''
TC: O(V+E) - since we created a graph and are iterating over it.
SC: O(n) - for storing lists for totalnodes, infectednodes and nodestogroup + have DFS 
            stack space
'''
import collections
from typing import List

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        ROWS, COLS = len(graph), len(graph[0])
        g = collections.defaultdict(set)
        for i in range(ROWS):
            for j in range(COLS):
                if graph[i][j] == 1 and i!=j:
                    g[i].add(j)
                    g[j].add(i)

        nodestogroup = [-1]*COLS

        def dfs(root, color):
            if nodestogroup[root] != -1:
                return
            nodestogroup[root] = color
            for neighbor in g[root]:
                dfs(neighbor, color)

        color = 0

        for root, v in enumerate(nodestogroup):
            if v == -1:
                dfs(root, color)
                color += 1

        infectednodes = [0]*(color)
        for i in initial:
            infectednodes[nodestogroup[i]] += 1
        
        totalnodes = [0]*color
        for n, g in enumerate(nodestogroup):
            totalnodes[g]+=1

        gans = float('inf')
        maxsave = -float('inf')
        for n in initial:
            g = nodestogroup[n]
            if infectednodes[g] == 1:
                if totalnodes[g]-infectednodes[g] > maxsave:
                    gans = n
                elif totalnodes[g]-infectednodes[g] == maxsave:
                    gans = min(gans, n)
                maxsave = max(maxsave, totalnodes[g]-infectednodes[g])
                
        return gans if gans!= float('inf') else min(initial)
s = Solution()
print(s.minMalwareSpread([[1,1,0],[1,1,0],[0,0,1]], [0,1]))
print(s.minMalwareSpread([[1,0,0],[0,1,0],[0,0,1]], [0,2]))
print(s.minMalwareSpread([[1,1,1],[1,1,1],[1,1,1]], [1,2]))
print(s.minMalwareSpread([[1,0,0,0],[0,1,0,0],[0,0,1,1],[0,0,1,1]], [3,1]))